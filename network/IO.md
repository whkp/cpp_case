# IO多路复用技术

**目的：用一个进程/线程来处理多个TCP连接，减少系统开销**

三种模型：select（1024个连接）、poll（数千）、epoll（百万）

## 网络通讯读事件

概念：指在网络编程中，当套接字（socket）上发生某些特定的读取相关事件时，操作系统内核会通知应用程序进行相应的处理

- 已经连接的队列中有已经准备好的socket（新的客户端连接）
- 接受缓存有数据可以读取（对端发送的报文已经到达）
- tcp连接已经断开（对端调用close函数关闭连接）



**网络通讯写事件**：发送缓冲区没满，可以写入数据（可以向对端发送报文）

## BIO 同步阻塞IO

底层流程：创建socket，通过bind将接口与端口号绑定，然后进行监听事件或者read读事件，会一直阻塞该命令，直到有客户端连接或者发送数据

**缺点：**单线程只有一个客户端连接，**多线程环境中要不断新建线程来接受客户端**

## NIO 同步非阻塞IO

开始流程和BIO一致，不过不会阻塞命令。

通过configblock函数传入参数false，底层命令为fcntl(socket 号，nonblock)将socket标记为非阻塞。

循环执行，有客户端连接返还一个新的socket号，将其加入list中，遍历list有无read事件，没有客户端连接循环执行

**缺点：**需要遍历list的每个集合查看有无监听事件，浪费CPU资源

***非阻塞IO调用connect函数***：不管连接是否成功，connect都会**立即返回失败**，对非阻塞IO调用connect函数后，如果socket状态可写，证明连接成功

调用accept函数：如果已连接队列中没有socket，函数立即返回失败

***非阻塞IO调用send、recv函数***：如果发送缓冲区已经满了（recv对应发送缓冲区为空），函数立即返回失败

## IO多路复用 select模型和poll模型

***IO复用的模型中，事件循环不能被阻塞在任何环节中，应采用非阻塞IO***

会阻塞的四个函数：connect()（三次连接会短暂的阻塞）, accept(), send(), recv() 

select可以监视多个socket的状态变化（写事件、读事件、异常）

进程通过告诉多路复用器（内核）（也就是select函数和poll函数）所有的socket号，多路复用器再去获取每一个socket的状态，当程序获取到某个socket号有事件发生了，则去该socket号上进行处理对应的事件，read事件或者是recived事件。（补充select函数与poll函数的区别是，前者底层是数组，所以有最大连接数的限制，后者是链表，无最大连接数的限制

select缺点：

- 采用轮询方式遍历bitmap，性能随着socket数量增多而下降
- 每次调用select，需要拷贝bitmap(select函数会修改bitmap)
- bitmap大小由宏设置，可以修改；bitmap越大效率越低



poll模型和select模型类似，

- 程序中poll数据结构为数组，传入内核后转换成了链表

- 每调用一次select需要拷贝两次bitmap（一次拷贝为临时，一次从用户态拷贝到内核态），poll拷贝一次结构体数组

- poll监视连接数没有1024的限制，但是也有遍历的方法，监视socket越多效率越低



## epoll

解决前两种方法效率低的问题。

**select和poll为水平触发**，当一个文件描述符准备好进行IO操作时，系统会持续通知应用程序，直到应用程序完全处理了该事件。

在 `epoll` 中，使用水平触发时，如果某个文件描述符可读，`epoll_wait` 会每次返回该文件描述符，直到数据被完全读取

- **水平触发**（LT）是一种较为保守的触发机制，每当文件描述符的状态符合条件时，系统都会持续通知应用程序，直到它处理完事件。适用于简单、负载不高的应用程序；

  - epoll_wait触发读事件表示有数据可以读，如果程序没有把数据读完，再次调用时将立即触发读事件；

    ```cpp
    epoll_event events[10]; //存放epoll返回事件
    ......//省略中间代码
    //事件循环中
    if(events[i].data.fd == listensock) {
    	//如果不处理一直会触发该事件
    }
    ```

    

  - 当发送缓冲区没有满，再次调用epoll_wait时可以立即触发写事件。

- **边缘触发**（ET）则在文件描述符状态变化时通知应用程序，只有状态改变时才会通知一次。它提高了性能，但要求应用程序能够高效地处理所有待处理事件，适用于需要高并发和高性能的场景。**(部分代码会不太一样)**

  - epoll_wait触发读事件后，不管程序有没有处理读事件，都不会再触发读事件，只有当新的数据到达时才会再次触发。（只处理一次）

    边缘触发要用非阻塞的socket，处理读事件时，应该采用循环，否则一次性可能接受不了太多；

    接受时采用循环读，单次就把一次发送的内容读取完全。

  - epoll_wait触发写事件后，如果发送缓冲区仍然可以写，不会再次触发写事件，只有发送缓冲区由满变成不满才会再次触发写事件

  
  
  ## epoll原理：
  
  ### 网卡接受数据过程：
  
  网卡收到网线数据，经过硬件电路传输到内存中的某个地址上。网卡会向CPU发出一个中断信号，操作系统便能得知有新数据到来，再通过网卡中断程序来处理数据。
  
  阻塞是进程调度关键的一环，指的是进程等待事件发生之前的等候状态，recv、select、epoll都是阻塞方法。
  
  ### **阻塞原理是：**
  
  进程分为“运行”和“等待”等几种状态。运行状态是进程获得CPU使用权，正在执行代码的状态；等候状态是阻塞状态。
  
  操作系统会**分时执行**各个运行状态的进程，由于速度很快，看上去就像是同时执行多个任务。
  
  在多个进程的环境下进程A运行着基础网络程序，进程A执行到创建socket的语句时，操作系统会创建一个文件系统管理的socket对象，包含了**发送缓冲区、接受缓冲区与等待队列**等成员，等待队列指向所有等待该socket的进程。程序执行到recv时，操作系统会将进程A从工作队列移动到socket的等待队列中。其他进程CPU轮流执行，不会在执行进程A的程序，所以进程A被阻塞，不会占用CPU资源。
  
  socket接受到数据时，操作系统会将socket从等待队列中重新放回工作队列，进程变为运行状态。
  
  操作系统是通过socket对应的端口号，凭借网络数据中的IP和端口信息找到对应的socket
  
  ### 如何同时监视多个socket数据呢？
  
  服务端需要监视多个客户端连接，recv只能监听单个socket。epoll要义就是高效监视多个socket。
  
  select思路：程序同时监视sock1、sock2、sock3这三个socket，调用select后，操作系统将进程A分别加入这三个socket的等待队列中。任何一个socket收到数据后，中断数据唤起进程（将进程从所有的等待队列中移除）。进程A被唤醒后，去遍历一遍socket列表就可以得到就绪的socket。
  
  存在以下缺点：
  
  每次调用select都需要将进程加入所有监视socket的等待队列，每次唤醒后都要从每个队列中移除，设计两次遍历；
  
  进程被唤醒后，程序不知道哪些socket收到数据，需要再遍历一次；
  
  （select调用时，会先遍历一遍socket，如果有一个以上的socket接受缓冲区有数据，select会直接返回，不会阻塞）
  
  ### Epoll设计思路
  
  - 措施一：功能分离
  
    select低效的原因是维护等待队列和阻塞进程合二为一，很多时候需要监视的socket固定并不需要修改
  
    epoll将两个操作分开，epoll_ctl维护等待队列，再用epoll_wait阻塞进程
  
    ```cpp
    int s = socket(AF_INET, SOCK)
    bind(s,...)
    listen(s,...)
    int epfd = epoll_create(...);
    epoll_ctl(epfd, ...) //将所有需要监听的socket添加到epfd
        
    while(1) {
        int n = epoll_wait(...)
        for(...) {
            //处理
        }
    }
    ```
  
    
  
  - 措施二：就绪列表
  
    select低效的原因在于程序不知道哪些socket收到数据，只能一个一个遍历，如果内核维护一个***就绪列表，引用收到数据的socket***，就能避免遍历。
  
    进程被唤醒后，只需要获取就绪列表的内容
  
  
  
  ### epoll流程
  
  1. 创建epoll对象：
  
     使用epoll_create方法时，内核会创建一个eventpoll对象，eventpoll对象也是文件系统的一员，和socket一样有等待队列。
     
  2. 维护监视列表：
  
     创建epoll对象后，使用epoll_ctl添加或删除要监听的socket。内核会将eventpoll添加到监听的socket的等待队列。
  
     socket接受到数据后，中断会操作eventpoll对象，而不是直接操作进程
  
  3. 接受数据：
  
     socket接受到数据后，中断程序会给eventpoll的“就绪列表”添加socket引用。
  
     eventpoll相当于是socket和进程之间的中介，socket数据接受并不影响进程，而是通过改变eventpoll的就绪列表来改变进程状态
  
     程序执行到epoll_wait时，如果rdlist（就绪列表）已经引用了socket，那么epoll_wait直接返回，如果rdlist为空，阻塞进程。
  
  4. 阻塞和唤醒进程:
  
     多个进程中如果进程A运行到了epoll_wait语句，内核会将进程A放入eventpoll的等待队列中，阻塞进程。
  
     当socket接受到数据时，中断程序会一方面修改rdlist，另一方面唤醒eventpoll等待队列中的进程，进程A再次进入运行状态
  
     因为rdlist存在，进程A知道哪些socket发生了变化
  
### epoll实现细节

​     eventpoll的数据结构是什么？

​	就绪列表引用就绪的socket，所以它应该能快速的插入数据，程序可能随时调用epoll_ctl添加socket，也可能随时删除。移除操作也应快速。

所以epoll采用双向链表来实现就绪队列（快速插入和删除的数据结构）。

​	epoll采用红黑树作为索引结构，能够方便的添加和移除，并且还便于搜索。（时间复杂度都是O（log2(N)））

  

  

  

  

  

